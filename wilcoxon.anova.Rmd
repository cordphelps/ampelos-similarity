---
title: "overhead"
output: html_document
date: "2023-02-20"
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

# this code will use the stats::kmeans() algorithm to identify clusters appearing in 
# weekly crab spider counts.

# https://yihui.org/knitr/options/

# echo: (TRUE; logical or numeric) Whether to display the source code
# results: ('markup'; character) Controls how to display the text results.
# warning: (TRUE; logical) Whether to preserve warnings
# error: (TRUE; logical) Whether to preserve errors
# include: (TRUE; logical) Whether to include the chunk output in the output document.
# 

```


```{r bytheway}

# what is the rank of insect occurrence?
  
  skimr::skim(bugs.tibl)


```




```{r bray-curtis-experimental, echo=FALSE, include=TRUE, results="hide", message=F, warning=T }


# count data from 10 spatial positions in a vineyard row; there are multiple sets of count 
# data for these rows. how to determine clusters of spatial positions based on counts 

# Simulate count data for 10 positions in 2 paired rows
#set.seed(123)
positions <- 1:10  # Positions along the row

# Create synthetic data (e.g., pest counts)

# rows of positions ; coulumns of weeks


library(ggplot2)
library(dplyr)

setwd("/Users/rcphelps/code/groq")
source('/Users/rcphelps/code/groq/bug-library.R') 
source('/Users/rcphelps/code/groq/wilcoxon-anova.R') 

# Mann-Whitney U Test (Wilcoxon Rank Sum Test)
#Purpose: Compares two independent groups to assess whether their distributions (usually medians) differ.
#Typical Use Case: Comparing values between two unrelated samples, such as test scores between two different classes, or measurements from two different transects
#R function: `wilcox.test(x, y, paired = FALSE)`

#Mann-Whitney U is for independent samples.
#	•	Wilcoxon Signed Rank is for paired/dependent samples.
#In summary:
#	•	Use the Mann-Whitney U test when comparing two independent groups.
#	•	Use the Wilcoxon Signed Rank test when comparing two related (paired) groups.
#Both tests are non-parametric and do not require the assumption of normality, but choosing the correct one depends on whether your samples are independent or paired


wilcoxon.output.tibl <- tibble(
  week = character(),
  am.W = numeric(), 
  am.p = numeric(), 
  pm.W = numeric(), 
  pm.p = numeric()
)

    wilcoxon.1.tibl <- dplyr::as_tibble(read.csv('./metrics/counts.position.control.am.csv', header=TRUE, row.names=NULL))
    wilcoxon.1.tibl <- wilcoxon.1.tibl %>%
        mutate(transect = "SNH") %>%
        mutate(time = "am") %>%
        mutate(position = c(1,2,3,4,5,6,7,8,9,10) )  
    
    # # A tibble: 10 × 13
    #      X23   X24   X25   X26   X27   X28   X29   X30   X31   X32
    #    <int> <int> <int> <int> <int> <int> <int> <int> <int> <int>
    #  1     1     5     0     0     0     4     0     2     0     1
    #  2     3     4     2     1     1     1     0     0     1     0
    #  3     0     3     1     0     1     1     0     0     0     0
    #  4     0     4     2     2     0     1     1     0     0     0
    #  5     0     4     4     2     0     1     1     0     0     0
    #  6     0     4     0     1     1     0     0     1     0     0
    #  7     4    12     5     1     0     4     1     2     1     0
    #  8     0     6     2     1     0     2     1     0     0     0
    #  9     0     1     2     1     1     5     0     1     0     1
    # 10     1     4     4     2     1     0     2     1     2     0
    # # ℹ 3 more variables: X34 <int>, transect <chr>, time <chr>

    
    wilcoxon.2.tibl <- dplyr::as_tibble(read.csv('./metrics/counts.position.control.am.csv', header=TRUE, row.names=NULL))
    wilcoxon.2.tibl <- wilcoxon.2.tibl %>%
        mutate(transect = "control") %>%
        mutate(time = "am") %>%
        mutate(position = c(1,2,3,4,5,6,7,8,9,10) )      
    
    wilcoxon.3.tibl <- dplyr::as_tibble(read.csv('./metrics/counts.position.SNH.pm.csv', header=TRUE, row.names=NULL))
    wilcoxon.3.tibl <- wilcoxon.3.tibl %>%
        mutate(transect = "SNH") %>%
        mutate(time = "pm") %>%
        mutate(position = c(1,2,3,4,5,6,7,8,9,10) )
    
    wilcoxon.4.tibl <- dplyr::as_tibble(read.csv('./metrics/counts.position.control.pm.csv', header=TRUE, row.names=NULL))
    wilcoxon.4.tibl <- wilcoxon.4.tibl %>%
        mutate(transect = "control") %>%
        mutate(time = "pm")  %>%
        mutate(position = c(1,2,3,4,5,6,7,8,9,10) )   
    
     #     X23   X24   X25   X26   X27   X28   X29   X30
     #   <int> <int> <int> <int> <int> <int> <int> <int>
     # 1    1     5     0     0     0     4     0     2
     #2     3     4     2     1     1     1     0     0
     #3     0     3     1     0     1     1     0     0
     #4     0     4     2     2     0     1     1     0
     #5     0     4     4     2     0     1     1     0
     #6     0     4     0     1     1     0     0     1
     #7     4    12     5     1     0     4     1     2
     #8     0     6     2     1     0     2     1     0
     #9     0     1     2     1     1     5     0     1
     #0     1     4     4     2     1     0     2     1
     ## ℹ 3 more variables: X31 <int>, X32 <int>, X34 <int>
    
    am.tibl <- bind_rows(wilcoxon.1.tibl, wilcoxon.2.tibl)
    pm.tibl <- bind_rows(wilcoxon.3.tibl, wilcoxon.4.tibl)
  
   

library(vegan)
# Reshape data into a matrix (rows = positions, columns = weeks)
count_matrix <- am.tibl[, c("X23", "X24", "X25", "X26", "X27", "X28", "X29", "X30", "X31", "X32", "X34")]

# Compute Bray-Curtis dissimilarity
bc_dist <- vegdist(count_matrix, method = "bray")

# Perform hierarchical clustering
hc <- hclust(bc_dist, method = "average")

# Cut tree into 3 clusters
clusters <- cutree(hc, k = 3)

# Attach cluster labels to original data
am.tibl$Cluster <- clusters

# Plot dendrogram
plot(hc)
rect.hclust(hc, k = 3, border = "red")

# Spatial plot of positions colored by cluster
library(ggplot2)
ggplot(data=am.tibl, aes(x = position, y = transect, fill = factor(Cluster))) +
  geom_tile(color = "white") +
  scale_fill_manual(values = c("royalblue", "darkorange", "green")) +
  labs(title = "am cluster Assignments by Vineyard Position")



library(vegan)
# Reshape data into a matrix (rows = positions, columns = weeks)
count_matrix <- pm.tibl[, c("X23", "X24", "X25", "X26", "X27", "X28", "X29", "X30", "X31", "X32", "X34")]

# Compute Bray-Curtis dissimilarity
bc_dist <- vegdist(count_matrix, method = "bray")

# Perform hierarchical clustering
hc <- hclust(bc_dist, method = "average")

# Cut tree into 3 clusters
clusters <- cutree(hc, k = 3)

# Attach cluster labels to original data
pm.tibl$Cluster <- clusters

# Plot dendrogram
plot(hc)
rect.hclust(hc, k = 3, border = "red")

# Spatial plot of positions colored by cluster
library(ggplot2)
ggplot(data=pm.tibl, aes(x = position, y = transect, fill = factor(Cluster))) +
  geom_tile(color = "white") +
  scale_fill_manual(values = c("royalblue", "darkorange", "green")) +
  labs(title = "pm cluster Assignments by Vineyard Position")

```




```{r bray-curtis-original, echo=FALSE, include=TRUE, results="hide", message=F, warning=T }

# count data from 10 spatial positions in a vineyard row; there are multiple sets of count 
# data for these rows. how to determine clusters of spatial positions based on counts 

# Simulate count data for 10 positions in 2 paired rows
#set.seed(123)
positions <- 1:10  # Positions along the row

# Create synthetic data (e.g., pest counts)
count_data <- data.frame(
  Position = rep(positions, 3),  # 10 positions x 2 rows
  Row = rep(c("Row_A", "Row_B", "Row_C"), each = 10),
  Pest_A = c(rpois(10, lambda = 5), rpois(10, lambda = 5), rpois(10, lambda = 5)),  # Higher in Row_B
  Pest_C = c(rpois(10, lambda = 5), rpois(10, lambda = 5), rpois(10, lambda = 5)),   # Higher in Row_A
  Pest_B = c(rpois(10, lambda = 5), rpois(10, lambda = 5), rpois(10, lambda = 5))   # Higher in Row_A
)

library(vegan)
# Reshape data into a matrix (rows = positions, columns = pests)
count_matrix <- count_data[, c("Pest_A", "Pest_B", "Pest_C")]

# Compute Bray-Curtis dissimilarity
bc_dist <- vegdist(count_matrix, method = "bray")

# Perform hierarchical clustering
hc <- hclust(bc_dist, method = "average")

# Cut tree into 2 clusters
clusters <- cutree(hc, k = 3)

# Attach cluster labels to original data
count_data$Cluster <- clusters

# Plot dendrogram
plot(hc, labels = paste("Pos", count_data$Position, "-", count_data$Row))
rect.hclust(hc, k = 2, border = "red")

# Spatial plot of positions colored by cluster
library(ggplot2)
ggplot(count_data, aes(x = Position, y = Row, fill = factor(Cluster))) +
  geom_tile(color = "white") +
  scale_fill_manual(values = c("royalblue", "darkorange", "green")) +
  labs(title = "Cluster Assignments by Vineyard Position")


```






```{r bug-wilcoxon, echo=FALSE, include=F, results='asis', message=F, warning=F}
library(ggplot2)
library(dplyr)

setwd("/Users/rcphelps/code/groq")
source('/Users/rcphelps/code/groq/bug-library.R') 
source('/Users/rcphelps/code/groq/wilcoxon-anova.R') 

# Mann-Whitney U Test (Wilcoxon Rank Sum Test)
#Purpose: Compares two independent groups to assess whether their distributions (usually medians) differ.
#Typical Use Case: Comparing values between two unrelated samples, such as test scores between two different classes, or measurements from two different transects
#R function: `wilcox.test(x, y, paired = FALSE)`

#Mann-Whitney U is for independent samples.
#	•	Wilcoxon Signed Rank is for paired/dependent samples.
#In summary:
#	•	Use the Mann-Whitney U test when comparing two independent groups.
#	•	Use the Wilcoxon Signed Rank test when comparing two related (paired) groups.
#Both tests are non-parametric and do not require the assumption of normality, but choosing the correct one depends on whether your samples are independent or paired


wilcoxon.output.tibl <- tibble(
  week = character(),
  am.W = numeric(), 
  am.p = numeric(), 
  pm.W = numeric(), 
  pm.p = numeric()
)

    wilcoxon.1.tibl <- dplyr::as_tibble(read.csv('./metrics/counts.position.SNH.am.csv', header=TRUE, row.names=NULL))
    wilcoxon.1.tibl <- wilcoxon.1.tibl %>%
        mutate(transect = "SNH") %>%
        mutate(time = "am") 
    
    # # A tibble: 10 × 13
    #      X23   X24   X25   X26   X27   X28   X29   X30   X31   X32
    #    <int> <int> <int> <int> <int> <int> <int> <int> <int> <int>
    #  1     1     5     0     0     0     4     0     2     0     1
    #  2     3     4     2     1     1     1     0     0     1     0
    #  3     0     3     1     0     1     1     0     0     0     0
    #  4     0     4     2     2     0     1     1     0     0     0
    #  5     0     4     4     2     0     1     1     0     0     0
    #  6     0     4     0     1     1     0     0     1     0     0
    #  7     4    12     5     1     0     4     1     2     1     0
    #  8     0     6     2     1     0     2     1     0     0     0
    #  9     0     1     2     1     1     5     0     1     0     1
    # 10     1     4     4     2     1     0     2     1     2     0
    # # ℹ 3 more variables: X34 <int>, transect <chr>, time <chr>

    
    wilcoxon.2.tibl <- dplyr::as_tibble(read.csv('./metrics/counts.position.control.am.csv', header=TRUE, row.names=NULL))
    wilcoxon.2.tibl <- wilcoxon.2.tibl %>%
        mutate(transect = "control") %>%
        mutate(time = "am")     
    
    wilcoxon.3.tibl <- dplyr::as_tibble(read.csv('./metrics/counts.position.SNH.pm.csv', header=TRUE, row.names=NULL))
    wilcoxon.3.tibl <- wilcoxon.3.tibl %>%
        mutate(transect = "SNH") %>%
        mutate(time = "pm") 
    
    wilcoxon.4.tibl <- dplyr::as_tibble(read.csv('./metrics/counts.position.control.pm.csv', header=TRUE, row.names=NULL))
    wilcoxon.4.tibl <- wilcoxon.4.tibl %>%
        mutate(transect = "control") %>%
        mutate(time = "pm")     
    
     #     X23   X24   X25   X26   X27   X28   X29   X30
     #   <int> <int> <int> <int> <int> <int> <int> <int>
     # 1    1     5     0     0     0     4     0     2
     #2     3     4     2     1     1     1     0     0
     #3     0     3     1     0     1     1     0     0
     #4     0     4     2     2     0     1     1     0
     #5     0     4     4     2     0     1     1     0
     #6     0     4     0     1     1     0     0     1
     #7     4    12     5     1     0     4     1     2
     #8     0     6     2     1     0     2     1     0
     #9     0     1     2     1     1     5     0     1
     #0     1     4     4     2     1     0     2     1
     ## ℹ 3 more variables: X31 <int>, X32 <int>, X34 <int>
    
    am.tibl <- bind_rows(wilcoxon.1.tibl, wilcoxon.2.tibl)
    pm.tibl <- bind_rows(wilcoxon.3.tibl, wilcoxon.4.tibl)
  
      
  for (i in c("X23", "X24", "X25", "X26", "X27", "X28", "X29", "X30", "X31", "X32", "X34")) {
  #for (i in c("X24")) {
    
    #result <- wilcox.test(weight ~ company, data = dat, conf.int = TRUE)
    #result$p.value
    #result$statistic    # "W"
    #result$conf.int   
    
    #model.am <- wilcox.test(X23 ~ transect, data = am.tibl)
    formula_string <- paste(i, "~", "transect")
    results.am <- wilcox.test(as.formula(formula_string), data = am.tibl, conf.int = TRUE)
    results.pm <- wilcox.test(as.formula(formula_string), data = pm.tibl, conf.int = TRUE)
    
    s.stat.am <- round(results.am$statistic, 2)
    s.p_val.am  <- round(results.am$p.value, 2)
    s.stat.pm <- round(results.am$statistic, 2)
    s.p_val.pm  <- round(results.pm$p.value, 2)
    
    wilcoxon.output.tibl <-  wilcoxon.output.tibl %>%
        add_row(week = sub("^X", "", i),         # regular expression to remove leading 'X'
                am.W = s.stat.am,
                am.p = s.p_val.am,
                pm.W = s.stat.pm,
                pm.p = s.p_val.pm
                )
    
    #print(paste("F: ", s.f_stat.am, "  p: ", s.p_val.am, sep=""))
    
  }
    
  #print(wilcoxon.output.tibl)
  # > print(anova.output.tibl)
# A tibble: 11 × 5
#   week   am.W  am.p  pm.W  pm.p
#   <chr> <dbl> <dbl> <dbl> <dbl>
# 1 23     60.5  0.42  60.5  0.25
# 2 24     36.5  0.32  36.5  0.4 
# 3 25     35.5  0.27  35.5  0.3 
# 4 26     36.5  0.29  36.5  0.41
# 5 27     42.5  0.54  42.5  0.47
# 6 28     38.5  0.39  38.5  0.79
# 7 29     64.5  0.26  64.5  0.22
# 8 30     55    0.71  55    0.18
# 9 31     67.5  0.16  67.5  0.43
#10 32     60    0.37  60    0.47
#11 34     55    0.37  55    0.3 
#> 

  setwd("/Users/rcphelps/code/groq/")
  write_csv(wilcoxon.output.tibl, "./metrics/wilcox.mwu.output.csv", append=FALSE)
    
  #======================= end Mann-Whitney U =============================
  #========================================================================
  #========================================================================
```


```{r bug-wilcoxonSRT, echo=F, include=TRUE, results='asis', message=F, warning=F}
#======================= begin Wilcoxon Signed Rank Test ================
#========================================================================
#========================================================================
  
#	Purpose: Compares two related (paired or matched) samples to assess whether 
# their median difference is zero.
#	Typical Use Case: Pre-test vs. post-test measurements on the same subjects, 
# or before-and-after measurements on the same plots.
# R function: `wilcox.test(x, y, paired = TRUE)`.

library(ggplot2)
library(dplyr)

setwd("/Users/rcphelps/code/groq")
source('/Users/rcphelps/code/groq/bug-library.R') 
source('/Users/rcphelps/code/groq/wilcoxon-anova.R') 
  

  #  ( './metrics/counts_week.csv' created by spider_lb.py week_compare_counts(df)  )
  wilcoxon.SRT.tibl <- dplyr::as_tibble(read.csv('./metrics/counts_week.csv', 
                                                   header=TRUE, row.names=NULL))
  
  wilcoxon.SRT.output.tibl <- tibble( transect = character(),
                                      time = character(), 
                                      week = character(), 
                                      p.value = numeric() )
  
  # # A tibble: 10 × 133
  #    oakMargin.pm.23.79 oakMargin.pm.23.81 oakMargin.pm.23.83
  #                 <int>              <int>              <int>
  #  1                  0                  1                  0
  #  2                  0                  0                  3
  #  3                  1                  0                  2
  #  4                  1                  0                  1
  #  5                  0                  3                  0
  #  6                  2                  2                  1
  #  7                  0                  0                  0
  #  8                  3                  0                  0
  #  9                  2                  1                  0
  # 10                  2                  1                  1
  # # ℹ 130 more variables: oakMargin.pm.24.80 <int>,
  # #   oakMargin.pm.24.82 <int>, oakMargin.pm.24.84 <int>,
  
  # ==============================================================================
  # get a list of column names from './metrics/counts_week.csv' (wilcoxon.SRT.tibl)
  # and build a temporary tibl that is used to filter to data for ggplot
  
  column_names <- names(wilcoxon.SRT.tibl)
  
  column_repo.tibl <- tibble(
        column.name = character(),
        transect = character(),
        time = character(),
        week = character(),
        row = character() )
  
  for (i in 1:length(column_names)) {
    text <- column_names[[i]]
    parts <- strsplit(text, "\\.")[[1]]
    column_repo.tibl <- add_row(column_repo.tibl, column.name = column_names[[i]], transect = parts[[1]],
                                 time = parts[[2]], week = parts[[3]], row = parts[[4]])
  }
  # # A tibble: 133 × 5
  #    column.name        transect  time  week  row  
  #    <chr>              <chr>     <chr> <chr> <chr>
  #  1 oakMargin.pm.23.79 oakMargin pm    23    79   
  #  2 oakMargin.pm.23.81 oakMargin pm    23    81   
  #  3 oakMargin.pm.23.83 oakMargin pm    23    83   
  #  4 oakMargin.pm.24.80 oakMargin pm    24    80   
  #  5 oakMargin.pm.24.82 oakMargin pm    24    82   
  #  6 oakMargin.pm.24.84 oakMargin pm    24    84   
  #  7 oakMargin.pm.25.81 oakMargin pm    25    81   
  #  8 oakMargin.pm.25.83 oakMargin pm    25    83   
  #  9 oakMargin.pm.25.85 oakMargin pm    25    85   
  # 10 oakMargin.pm.26.83 oakMargin pm    26    83   
  # # ℹ 123 more rows
  
  # ==============================================================================
  
  # find rows from the same transect / time / week for comparison
  
  for (tr in c("oakMargin", "control")) {
    
    for (daytime in c("am", "pm")) {
      
      for (wk in c("23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "34")) {
      #for (wk in c("24")) {
        
        same_week_columns.tibl <- column_repo.tibl %>%
          filter(transect == tr) %>%
          filter(time == daytime) %>%
          filter(week == wk) 
        
        # # A tibble: 3 × 5
        #   column.name        transect  time  week  row  
        #   <chr>              <chr>     <chr> <chr> <chr>
        # 1 oakMargin.am.24.80 oakMargin am    24    80   
        # 2 oakMargin.am.24.82 oakMargin am    24    82   
        # 3 oakMargin.am.24.84 oakMargin am    24    84   
        # > 
        
        # there should be no more than 3 columns (in wilcoxon.SRT.tibl)
        # which means we are looking for 3 rows (the column labels)
        # in column_repo.tibl
        # 
        
        if (nrow(same_week_columns.tibl) == 3) {
          
          # This gets the column as a vector, then takes the first element.
          column_name_1 <- same_week_columns.tibl$column.name[1]
          column_name_2 <- same_week_columns.tibl$column.name[2]
          column_name_3 <- same_week_columns.tibl$column.name[3]
    
          # now run wilcoxon SRT on the data from each column
          # returns an object of class `"htest"`
          
          results.1 <- wilcox.test(wilcoxon.SRT.tibl[[column_name_1]], 
                                    wilcoxon.SRT.tibl[[column_name_2]], paired = TRUE)
          results.2 <- wilcox.test(wilcoxon.SRT.tibl[[column_name_1]], 
                                    wilcoxon.SRT.tibl[[column_name_3]], paired = TRUE)
          results.3 <- wilcox.test(wilcoxon.SRT.tibl[[column_name_2]], 
                                    wilcoxon.SRT.tibl[[column_name_3]], paired = TRUE)
          
          wilcoxon.SRT.output.tibl <-  wilcoxon.SRT.output.tibl %>%
                add_row(transect = tr, time = daytime, week = wk, p.value = round(results.1$p.value, 2) )
          wilcoxon.SRT.output.tibl <-  wilcoxon.SRT.output.tibl %>%
                add_row(transect = tr, time = daytime, week = wk, p.value = round(results.2$p.value, 2) )
          wilcoxon.SRT.output.tibl <-  wilcoxon.SRT.output.tibl %>%
                add_row(transect = tr, time = daytime, week = wk, p.value = round(results.3$p.value, 2) )
          
        }
        
        if (nrow(same_week_columns.tibl) == 2) {
          
          column_name_1 <- same_week_columns.tibl[[1, column.name]]
          column_name_2 <- same_week_columns.tibl[[2, column.name]]
          
          # now run wilcoxon SRT on the data from each column
          # returns an object of class `"htest"`
          
          results.1 <- wilcox.test(wilcoxon.SRT.tibl[[column_name_1]], 
                                    wilcoxon.SRT.tibl[[column_name_2]], paired = TRUE)
          
          wilcoxon.SRT.output.tibl <-  wilcoxon.SRT.output.tibl %>%
                add_row(transect = tr, time = daytime, week = wk, p.value = round(results.1$p.value, 2) )
          
        }
        
        
      }
    }
  }
  
  setwd("/Users/rcphelps/code/groq/")
  write_csv(wilcoxon.SRT.output.tibl, "./metrics/wilcox.srt.output.csv", append=FALSE)
  
  
    
```



```{r wilcox-gg-SRT, echo=TRUE, include=TRUE, results='asis', message=F, warning=F}

  library(ggplot2)
  library(dplyr)
  library(tidyr)

  source('/Users/rcphelps/code/groq/bug-library.R') 
  
  setwd("/Users/rcphelps/code/groq")
  
  
  input_filename = "./metrics/wilcox.srt.output.csv"
  wilcoxon.SRT.gg.input.tibl <- dplyr::as_tibble(read.csv(input_filename, header=TRUE, row.names=NULL))
  
  # # A tibble: 129 × 4
  #    transect  time  week  p.value
  #    <chr>     <chr> <chr>   <dbl>
  #  1 oakMargin am    23       0.34
  #  2 oakMargin am    23       0.18
  #  3 oakMargin am    23       0.15
  #  4 oakMargin am    24       0.71
  #  5 oakMargin am    24       0.26
  #  6 oakMargin am    24       0.17
  #  7 oakMargin am    25       0.33
  #  8 oakMargin am    25       0.17
  #  9 oakMargin am    25       0.46
  # 10 oakMargin am    26       0.48
  # ℹ 119 more rows
  # ℹ Use `print(n = ...)` to see more rows
  
    color_list <- list("royalblue4", "royalblue3", "royalblue2", "darkorange4", "darkorange3", "darkorange2")
    # https://sape.inf.usi.ch/quick-reference/ggplot2/colour
  
    for (tr in c("oakMargin", "control")) {
      
      if (tr == "oakMargin") {
        tr.label = "SNH"
        fill.color = "royalblue3"
      } else {
        tr.label = "control"
        fill.color = "darkorange3"
      }
      
      for (daytime in c("am", "pm")) {
        
          gg.tibl <- wilcoxon.SRT.gg.input.tibl %>%
                dplyr::filter(transect == tr) %>%
                dplyr::filter(time == daytime) 
          gg.tibl <- tidyr::drop_na(gg.tibl)
            
          gg.box <- ggplot() +
          
              geom_boxplot(data = gg.tibl, aes(x = as.factor(week), y = p.value), fill=fill.color) +
              
              scale_y_continuous(limits=c(0, 1.1), breaks=seq(0, 1.1, 0.1) ) +
              
              theme_bw() +
              
              labs(y = "row pair p-values", x = paste("week"),
                   caption = paste("daily row counts compared\n", "transect: ", tr.label, " daytime: ", daytime, sep="" ))
              
          print(gg.box)  
          setwd("/Users/rcphelps/code/groq/")
          saveGGpng(filename = paste("f.row.triplet.box.", tr, ".", daytime, ".png", sep=""), 
                    subdir = "png.output", gg = gg.box)
  
      }
    }
    
            
  
```

    



```{r bug-anova, echo=FALSE, include=TRUE, results='asis', message=F, warning=F}

library(ggplot2)
library(dplyr)

setwd("/Users/rcphelps/code/groq")
source('/Users/rcphelps/code/groq/bug-library.R') 
source('/Users/rcphelps/code/groq/anova.R') 

anova.output.tibl <- tibble(
  week = character(),
  am.f = numeric(), 
  am.p = numeric(), 
  pm.f = numeric(), 
  pm.p = numeric()
)

    anova.1.tibl <- dplyr::as_tibble(read.csv('./metrics/counts.position.SNH.am.csv', header=TRUE, row.names=NULL))
    anova.1.tibl <- anova.1.tibl %>%
        mutate(transect = "SNH") %>%
        mutate(time = "am") 
    
    anova.2.tibl <- dplyr::as_tibble(read.csv('./metrics/counts.position.control.am.csv', header=TRUE, row.names=NULL))
    anova.2.tibl <- anova.2.tibl %>%
        mutate(transect = "control") %>%
        mutate(time = "am")     
    
    anova.3.tibl <- dplyr::as_tibble(read.csv('./metrics/counts.position.SNH.pm.csv', header=TRUE, row.names=NULL))
    anova.3.tibl <- anova.3.tibl %>%
        mutate(transect = "SNH") %>%
        mutate(time = "pm") 
    
    anova.4.tibl <- dplyr::as_tibble(read.csv('./metrics/counts.position.control.pm.csv', header=TRUE, row.names=NULL))
    anova.4.tibl <- anova.4.tibl %>%
        mutate(transect = "control") %>%
        mutate(time = "pm")     
    
    
     #     X23   X24   X25   X26   X27   X28   X29   X30
     #   <int> <int> <int> <int> <int> <int> <int> <int>
     # 1    1     5     0     0     0     4     0     2
     #2     3     4     2     1     1     1     0     0
     #3     0     3     1     0     1     1     0     0
     #4     0     4     2     2     0     1     1     0
     #5     0     4     4     2     0     1     1     0
     #6     0     4     0     1     1     0     0     1
     #7     4    12     5     1     0     4     1     2
     #8     0     6     2     1     0     2     1     0
     #9     0     1     2     1     1     5     0     1
     #0     1     4     4     2     1     0     2     1
     ## ℹ 3 more variables: X31 <int>, X32 <int>, X34 <int>
    
    am.tibl <- bind_rows(anova.1.tibl, anova.2.tibl)
    pm.tibl <- bind_rows(anova.3.tibl, anova.4.tibl)
  
      
  for (i in c("X23", "X24", "X25", "X26", "X27", "X28", "X29", "X30", "X31", "X32", "X34")) {
  #for (i in c("X24")) {
    
    #model.am <- aov(X23 ~ transect, data = am.tibl)
    formula_string <- paste(i, "~", "transect")
    model.am <- aov(as.formula(formula_string), data = am.tibl)
    model.pm <- aov(as.formula(formula_string), data = pm.tibl)
  
      #summary(model.pm)
      #            Df Sum Sq Mean Sq F value Pr(>F)
      #transect     1    3.2    3.20    1.14    0.3
      #Residuals   18   50.6    2.81               
      #> summary(model.am)
      #            Df Sum Sq Mean Sq F value Pr(>F)
      #transect     1   0.05    0.05    0.03   0.86
      #Residuals   18  26.90    1.49 
  
    results.am <- summary(model.am)
    results.pm <- summary(model.pm)
    
    s.f_stat.am <- round(results.am[[1]][["F value"]][1], 2)
    s.p_val.am  <- round(results.am[[1]][["Pr(>F)"]][1], 2)
    s.f_stat.pm <- round(results.pm[[1]][["F value"]][1], 2)
    s.p_val.pm  <- round(results.pm[[1]][["Pr(>F)"]][1], 2)
    
    anova.output.tibl <-  anova.output.tibl %>%
        add_row(week = sub("^X", "", i),         # regular expression to remove leading 'X'
                am.f = s.f_stat.am,
                am.p = s.p_val.am,
                pm.f = s.f_stat.pm,
                pm.p = s.p_val.pm
                )
    
    #print(paste("F: ", s.f_stat.am, "  p: ", s.p_val.am, sep=""))
    
  }
    
  print(anova.output.tibl)
  # > print(anova.output.tibl)
  # # A tibble: 11 × 5
  # #    week   am.f  am.p  pm.f  pm.p
  # #    <chr> <dbl> <dbl> <dbl> <dbl>
  # #  1 23     0.03  0.86  1.14  0.3 
  # #  2 24     0.59  0.45  0.68  0.42
  # #  3 25     1.8   0.2   1.36  0.26
  # #  4 26     0.2   0.66  1.19  0.29
  # #  5 27     0.13  0.72  0.95  0.34
  # #  6 28     1.45  0.24  0.03  0.87
  # #  7 29     1.69  0.21  1.14  0.3 
  # #  8 30     0.4   0.53  1.17  0.29
  # #  9 31     2.62  0.12  0.65  0.43
  # # 10 32     0.9   0.36  0.38  0.55
  # # 11 34     1     0.33  1.2   0.29
  # # > 

  setwd("/Users/rcphelps/code/groq/")
  write_csv(anova.output.tibl, "./metrics/anova.output.csv")
    
  #     TukeyHSD(one.way)
```




